<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://heejung-gjt.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://heejung-gjt.github.io/" rel="alternate" type="text/html" /><updated>2021-09-17T10:18:28+09:00</updated><id>https://heejung-gjt.github.io/</id><title type="html">Studying  Develop</title><subtitle>개발 공부하는 블로그</subtitle><entry><title type="html">0916 TIL</title><link href="https://heejung-gjt.github.io/til48" rel="alternate" type="text/html" title="0916 TIL" /><published>2021-09-16T20:50:00+09:00</published><updated>2021-09-16T20:50:00+09:00</updated><id>https://heejung-gjt.github.io/til48</id><content type="html" xml:base="https://heejung-gjt.github.io/til48">&lt;h2 id=&quot;210916-계획&quot;&gt;210916 계획&lt;/h2&gt;

&lt;h4 id=&quot;am-1120-&quot;&gt;AM 11:20 ~&lt;/h4&gt;

&lt;p&gt;내일부터는 무조건 운동을 할 예정이다 ! 내 등살이 장난아니다…..&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;해야-할-일&quot;&gt;해야 할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;dfs/bfs 알고리즘 9466, 2667, 4963, 7976&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;기본 알고리즘 11650, 1165, 10814&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;dp 11726&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;네트워크 소켓 정리&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;python 메모리 관리 과정&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;python is vs ==&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;오늘 공부했던 소켓이나 파이썬 메모리 둘다 꽤 흥미로웠고 재밌었다 ^^ 둘다 강의를 참고하여 들었는데 발표하는 분들 정말
대단해보였다.. 내일 다시 복습해야지 ~!&lt;/p&gt;</content><author><name>jung</name></author><category term="til" /><summary type="html"></summary></entry><entry><title type="html">(Python) is와 == 의 차이점</title><link href="https://heejung-gjt.github.io/python13" rel="alternate" type="text/html" title="(Python) is와 == 의 차이점" /><published>2021-09-16T18:20:00+09:00</published><updated>2021-09-16T18:20:00+09:00</updated><id>https://heejung-gjt.github.io/python13</id><content type="html" xml:base="https://heejung-gjt.github.io/python13">&lt;!--&lt;span class=&quot;table-of-contents-list&quot;&gt;Python 목록 순서 &lt;/span&gt;--&gt;
&lt;!--&lt;ul class=&quot;table-of-contents-list&quot;&gt;--&gt;
&lt;!--    &lt;li&gt;&lt;a href=&quot;./python-DataStructure&quot;&gt;Python 강좌(1) - 자료구조&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li class=&quot;content01 content&quot;&gt;1. 리스트&lt;/li&gt;--&gt;
&lt;!--    &lt;li class=&quot;content02 content&quot;&gt;2. 튜플&lt;/li&gt;--&gt;
&lt;!--    &lt;li class=&quot;content03 content&quot;&gt;3. 딕셔너리&lt;/li&gt;--&gt;
&lt;!--    &lt;li class=&quot;content04 content&quot;&gt;4. 문자열 리스트로 변환 후 딕셔너리 변환&lt;/li&gt;--&gt;
&lt;!--    &lt;li &gt;&lt;a href=&quot;./python-Function&quot;&gt;Python 강좌(2) - 함수&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li &gt;&lt;a href=&quot;./python-INOutput&quot;&gt;Python 강좌(3) - 입출력&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li &gt;&lt;a href=&quot;./python-Class&quot;&gt;Python 강좌(4) - 클래스&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li &gt;&lt;a href=&quot;./python-Exception&quot;&gt;Python 강좌(5) - 예외처리&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--&lt;/ul&gt;--&gt;

&lt;!--&lt;script&gt;--&gt;
&lt;!--    const content = document.querySelector('.content')--&gt;
&lt;!--    const lists01 = document.querySelector('.content01');--&gt;
&lt;!--    const lists02 = document.querySelector('.content02');--&gt;
&lt;!--    const lists03 = document.querySelector('.content03');--&gt;
&lt;!--    const lists04 = document.querySelector('.content04');--&gt;
&lt;!--    lists01.addEventListener('click',(event)=&gt;{--&gt;
&lt;!--        window.scrollTo(0,850);--&gt;
&lt;!--    });--&gt;
&lt;!--    lists02.addEventListener('click',(event)=&gt;{--&gt;
&lt;!--        window.scrollTo(0,3500);--&gt;
&lt;!--    });--&gt;
&lt;!--    lists03.addEventListener('click',(event)=&gt;{--&gt;
&lt;!--        window.scrollTo(0,4700);--&gt;
&lt;!--    });--&gt;
&lt;!--    lists04.addEventListener('click',(event)=&gt;{--&gt;
&lt;!--        window.scrollTo(0,8300);--&gt;
&lt;!--    });--&gt;

&lt;!--&lt;/script&gt;--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;a-is-b&quot;&gt;a is b&lt;/h2&gt;

&lt;p&gt;is는 메모리 주소를 비교하는 연산자이다.  아래의 코드를 보면 a와 b 둘다 동일한 값이 할당되었지만 실제 비교가 되는 값은
100이 아니라 100을 담고 있는 주소의 값이 비교된다. 이때 a와 b는 다른 메모리주소를 가지고 있기 때문에 두개의 주소값은
동일하지 않다&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# False&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;a--b&quot;&gt;a == b&lt;/h2&gt;

&lt;p&gt;==는 두개의 값만을 비교하는 연산자이다. 아래의 코드를 보면 할당된 값은 동일하기 때문에 True가 나온다&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# True&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;is는 == 에 비해 약간 빠르다&lt;/strong&gt;  &lt;br /&gt;
== 는 메모리 주소를 불러온 뒤 그 메모리에 저장되어 있는 값을 비교하고 is는 메모리 주소만을 비교하기 때문이다. 즉 
==는 한 depth더 비교하기 때문에 연산이 살짝 느린것을 알 수 있다&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;변수&lt;/strong&gt;  &lt;br /&gt;
특정 메모리 주소를 담아서 메모리 주소에 붙이는 라벨과 같다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;파이썬에서는 변수는 값이 아닌 메모리 주소를 담고 있다&lt;/p&gt;</content><author><name>jung</name></author><category term="python" /><summary type="html"></summary></entry><entry><title type="html">(Python) 파이썬 메모리 관리</title><link href="https://heejung-gjt.github.io/python12" rel="alternate" type="text/html" title="(Python) 파이썬 메모리 관리" /><published>2021-09-16T17:20:00+09:00</published><updated>2021-09-16T17:20:00+09:00</updated><id>https://heejung-gjt.github.io/python12</id><content type="html" xml:base="https://heejung-gjt.github.io/python12">&lt;!--&lt;span class=&quot;table-of-contents-list&quot;&gt;Python 목록 순서 &lt;/span&gt;--&gt;
&lt;!--&lt;ul class=&quot;table-of-contents-list&quot;&gt;--&gt;
&lt;!--    &lt;li&gt;&lt;a href=&quot;./python-DataStructure&quot;&gt;Python 강좌(1) - 자료구조&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li class=&quot;content01 content&quot;&gt;1. 리스트&lt;/li&gt;--&gt;
&lt;!--    &lt;li class=&quot;content02 content&quot;&gt;2. 튜플&lt;/li&gt;--&gt;
&lt;!--    &lt;li class=&quot;content03 content&quot;&gt;3. 딕셔너리&lt;/li&gt;--&gt;
&lt;!--    &lt;li class=&quot;content04 content&quot;&gt;4. 문자열 리스트로 변환 후 딕셔너리 변환&lt;/li&gt;--&gt;
&lt;!--    &lt;li &gt;&lt;a href=&quot;./python-Function&quot;&gt;Python 강좌(2) - 함수&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li &gt;&lt;a href=&quot;./python-INOutput&quot;&gt;Python 강좌(3) - 입출력&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li &gt;&lt;a href=&quot;./python-Class&quot;&gt;Python 강좌(4) - 클래스&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li &gt;&lt;a href=&quot;./python-Exception&quot;&gt;Python 강좌(5) - 예외처리&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--&lt;/ul&gt;--&gt;

&lt;!--&lt;script&gt;--&gt;
&lt;!--    const content = document.querySelector('.content')--&gt;
&lt;!--    const lists01 = document.querySelector('.content01');--&gt;
&lt;!--    const lists02 = document.querySelector('.content02');--&gt;
&lt;!--    const lists03 = document.querySelector('.content03');--&gt;
&lt;!--    const lists04 = document.querySelector('.content04');--&gt;
&lt;!--    lists01.addEventListener('click',(event)=&gt;{--&gt;
&lt;!--        window.scrollTo(0,850);--&gt;
&lt;!--    });--&gt;
&lt;!--    lists02.addEventListener('click',(event)=&gt;{--&gt;
&lt;!--        window.scrollTo(0,3500);--&gt;
&lt;!--    });--&gt;
&lt;!--    lists03.addEventListener('click',(event)=&gt;{--&gt;
&lt;!--        window.scrollTo(0,4700);--&gt;
&lt;!--    });--&gt;
&lt;!--    lists04.addEventListener('click',(event)=&gt;{--&gt;
&lt;!--        window.scrollTo(0,8300);--&gt;
&lt;!--    });--&gt;

&lt;!--&lt;/script&gt;--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;파이썬-메모리-관리&quot;&gt;파이썬 메모리 관리&lt;/h2&gt;

&lt;p&gt;파이썬은 메모리를 직접 관리하지 않기 때문에 메모리에 대한 신경을 다른 언어에 비해 덜 쓸 수 있다. 파이썬에서는 &lt;strong&gt;레퍼런스 카운트(Reference Counts)와 가비지 콜렉션(Garbage Collection)에 의해 관리된다&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;레퍼런스-카운트&quot;&gt;레퍼런스 카운트&lt;/h2&gt;
&lt;p&gt;파이썬은 내부적으로 malloc()과 free() 함수를 많이 사용하기 때문에 메모리 누수(동적 할당 되는 메모리의 크기는 런타임 내내 변하기 때문에 사용이 끝난 메모리를 해제하지 않으면 메모리가 부족해지는 현상)의 위험이 있다. 그렇기 때문에 메모리를 관리하기 위해서 사용된다  &lt;br /&gt;
레퍼런스 카운트는 &lt;strong&gt;파이썬의 모든 객체에 카운트를 포함하고 객체가 참조될때 카운트가 증가, 참조가 삭제될때 카운트를 감소시키는 방식으로 작동된다.&lt;/strong&gt;  객체의 reference count가 0이 되면 객체의 메모리 할당이 해제된다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;malloc()&lt;/strong&gt;    &lt;br /&gt;
동적으로 &lt;strong&gt;메모리를 할당하는 함수&lt;/strong&gt; 로 힙 영역에 메모리를 할당하는 함수&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;free()&lt;/strong&gt;      &lt;br /&gt;
힙 영역에 할당받은 메모리 공간을 다시 os로 반환해주는 함수이다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;특정 메모리 주소를 참조하는 곳의 수가 0이 될 경우 다음 GC때 메모리에서 해제가 된다&lt;/p&gt;

&lt;p&gt;레퍼런스 카운트는 getrefcount()를 통해 파라미터로 전달된 객체의 카운트를 확인할 수 있다  &lt;br /&gt;
(여기서 처음 출력되는 카운트 값이 1이 아닌 이유는 a의 객체가 getrefcount함수의 인자로 넘어가기 때문에 인자로 넘겨주는 순간 +1 이 된다)&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'hello'&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'count {sys.getrefcount(a)}'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'count {sys.getrefcount(a)}'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'count {sys.getrefcount(a)}'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'count {sys.getrefcount(a)}'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
count 2
count 3
count 4
count 3
&quot;&quot;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;순환참조시-레퍼런스-카운트-문제&quot;&gt;순환참조시 레퍼런스 카운트 문제&lt;/h3&gt;

&lt;p&gt;이때 레퍼런스 카운트에는 문제가 존재한다. 순환참조시 a의 참조횟수는 1이지만 이 객체에는 더이상 접근할 수 없고 레퍼런스 카운트 방식으로는 메모리에서 해제될 수 없다&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;del&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;순환참조&lt;/strong&gt;  &lt;br /&gt;
객체가 자기 자신을 가리키는 것을 말한다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이때 가비지 컬렉션을 사용하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;generational-garbage-collector&quot;&gt;Generational Garbage Collector&lt;/h2&gt;
&lt;p&gt;gc는 내부적으로 &lt;strong&gt;세대&lt;/strong&gt; 와 &lt;strong&gt;임계값&lt;/strong&gt; 을 통해서 가비지 컬렉션 주기와 객체를 관리한다. 
총 3세대가 있으며 최근에 생성된 객체는 0세대로 들어가고 오랜된 객체는 이전 세대로 이동한다.&lt;/p&gt;

&lt;p&gt;(최근 생성된 객체는 0세대에 들어가고 오래된 객체일수록 2세대로 이동된다. 그 이유는 최근에 만들어진 객체가 오래된 객체보다 해제될 가능성이 훨씬 높다는 가설이 있기 때문이다)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;generation(세대)&lt;/strong&gt; : 가비지 컬렉터는 메모리의 모든 객체를 추적하는데 새로운 객체는 1세대 가비지 수집기에서 수명을 시작한다. 가비지 컬렉션이 실행되고 객체가 남아있으면 해당 객체는 두번째 이전 세대로 올라간다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;threshold(임계값)&lt;/strong&gt; : 각 세대마다 즉 각 제너레이션마다 가비지 커렉터 모듈에는 임계값 개수의 개체가 있다. 객체 수가 임계값을 초과하면 가비지 컬렉션이 실행되고 이 과정에서 살아남은 객체는 이전 세대로 옮겨진다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;가비지 컬렉션을 사용하기 위해서 GC module을 사용한다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;메모리-할당-내부-동작&quot;&gt;메모리 할당 내부 동작&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;PyObject_GC_MALLOC()&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;collect_generations()&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;gc의 set_threshold()는 가비지 컬렉터의 구성된 임계값을 확인할 수 있다. 만약 아래처럼 임계값이 3인 경우라고 가정하자(각 제너레이션, 즉 각 세대에 들어갈 수 있는 객체의 최대값)&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;gc&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;gc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_threshold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;값이 할당되면 파이썬 내부적으로 PyObject_GC_Malloc() 함수가 호출되어 hi라는 값은 메모리에 할당되게 된다. 이후 해당 함수는 할당된 메모리 주소를 리턴하게 되고 메모리 주소는 a로 들어가게 된다. 제너레이터(0세대)에는 hi라는 값이 들어가게 된다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'hi'&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;PyObject_GC_Malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;b라는 변수에 how라는 값을 넣었고 마찬가지로 PyObject_GC_Malloc() 함수가 호출되어 how라는 값은 메모리에 할당되게 된다. 이후 how값은 제너레이터(0세대)에 들어가게 된다&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'how'&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;PyObject_GC_Malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;c라는 변수에 are라는 값을 넣었고 PyObject_GC_Malloc() 함수가 호출되어 are라는 값은 메모리에 할당되게 된다. 이후 are값은 제너레이터(0세대)에 들어가게 된다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'you'&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;PyObject_GC_Malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이후 you라는 값이 함수 호출에 의해 메모리에 할당되는데 제너레이터의 임계값은 3이기 때문에 you가 들어가면 threshold를 초과하게 된다. 
더이상 0세대에는 변수를 할당할 수 없게 된다. &lt;br /&gt;
이때는 &lt;strong&gt;PyObject_GC_Malloc()함수에서 collect_generations(–)라는 함수를 호출한다&lt;/strong&gt; collect_generstions은 이전 세대부터 각 객체가 몇개 들어가 있는지 체크한다. 체크한뒤 초과가 된 제너레이션을 찾아 초과가 된 세대에 가비지 컬렉터를 돌리라는 명령을 한다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;collect함수는 0세대에 있는 모든 값들을 불러온 뒤 값의 레퍼런스 카운트를 체크한다. 레퍼런스 카운트가 0일 경우 값을 메모리에서 지우게 된다. 0이 아닌 경우 해당 값은 위의 제너레이션 즉 1세대로 올리게 된다.  즉 1세대에는 hi, how, are라는 값들이 저장되고 0세대에는 you라는 값이 저장된다.&lt;/p&gt;

&lt;p&gt;가비지 컬렉터는 제너레이션에 값들이 임계값을 초과할 경우 동작해서 레퍼런스 카운트 값이 0일때 해당 값을 지워주고 나머지 값들은 이전 세대로 올리는 역할을 한다&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h5 id=&quot;reference&quot;&gt;reference&lt;/h5&gt;

&lt;p&gt;두개의 글과 동영상 정리가 잘 되어 있으니 참고해보길 !&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=UwGHc6A0Jq8&amp;amp;t=1613s&quot;&gt;https://www.youtube.com/watch?v=UwGHc6A0Jq8&amp;amp;t=1613s&lt;/a&gt;  &lt;br /&gt;
&lt;a href=&quot;https://dc7303.github.io/python/2019/08/06/python-memory/&quot;&gt;https://dc7303.github.io/python/2019/08/06/python-memory/&lt;/a&gt;&lt;/p&gt;</content><author><name>jung</name></author><category term="python" /><summary type="html"></summary></entry><entry><title type="html">0915 TIL</title><link href="https://heejung-gjt.github.io/til47" rel="alternate" type="text/html" title="0915 TIL" /><published>2021-09-15T17:50:00+09:00</published><updated>2021-09-15T17:50:00+09:00</updated><id>https://heejung-gjt.github.io/til47</id><content type="html" xml:base="https://heejung-gjt.github.io/til47">&lt;h2 id=&quot;210915-계획&quot;&gt;210915 계획&lt;/h2&gt;

&lt;h4 id=&quot;am-1150-&quot;&gt;AM 11:50 ~&lt;/h4&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;해야-할-일&quot;&gt;해야 할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;bfs/dfs 알고리즘 문제 11724, 11052, 1463(dp) 문제 풀이&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;감자마켓 프로젝트 페이징 구현하기&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;필터기능 ajax, post -&amp;gt; get방식으로 변경(추후 정리예정)&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;검색기능 새로운 페이지 생성&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;실제로 get을 이론적으로 이해한것과 사용하는 것에는 아주 큰 차이가 있었다. get의 특징에 대해서는 알고 있었지만
내가 실제로 구현할때는 제대로 사용하지 않았던것이다… 아주 기본적인 것을 놓치고 있었다는 생각이 들었다. 그리고 get으로 요청받으니까
구현하기 까다로웠던 문제가 쉽게 풀려서 신기했다 ! ㅋㅋㅋ (난 왜 지금까지 몰랐던 것인가….)&lt;/p&gt;</content><author><name>jung</name></author><category term="til" /><summary type="html"></summary></entry><entry><title type="html">0914 TIL</title><link href="https://heejung-gjt.github.io/til46" rel="alternate" type="text/html" title="0914 TIL" /><published>2021-09-14T17:50:00+09:00</published><updated>2021-09-14T17:50:00+09:00</updated><id>https://heejung-gjt.github.io/til46</id><content type="html" xml:base="https://heejung-gjt.github.io/til46">&lt;h2 id=&quot;210914-계획&quot;&gt;210914 계획&lt;/h2&gt;

&lt;h4 id=&quot;am-1150-&quot;&gt;AM 11:50 ~&lt;/h4&gt;

&lt;p&gt;요즘 늦게 공부를 시작한다.. 운동을 해야 하는데 생각만큼 쉽지가 않아서 고민이다(운동 계획했던 시간에 누워있는 1인…)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;해야-할-일&quot;&gt;해야 할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;9013 알고리즘 다시 풀어보기(2011, 11052)&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;bfs/dfs 이론정리하기&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;bfs/dfs 1260, 11724 문제 풀이&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;jwt crud 구현하기(구현중….)&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;감자마켓 프로젝트 검색기능 추가하기&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;진행했던 프로젝트의 버전업을 위해 새로운 기능을 추가하고 리팩토링 하는 과정은 정말 쉽지 않다 ㅋㅋㅋ
그래도 하나씩 수정되어가는 모습을 보니 빨리 계획한 마지막 버전까지 꾸준히 업데이트 시켜보고 싶다 ~~!&lt;/p&gt;</content><author><name>jung</name></author><category term="til" /><summary type="html"></summary></entry><entry><title type="html">Socket이란, WebSocket이란</title><link href="https://heejung-gjt.github.io/socket" rel="alternate" type="text/html" title="Socket이란, WebSocket이란" /><published>2021-09-14T17:32:00+09:00</published><updated>2021-09-14T17:32:00+09:00</updated><id>https://heejung-gjt.github.io/socket</id><content type="html" xml:base="https://heejung-gjt.github.io/socket">&lt;!--&lt;span class=&quot;table-of-contents-list&quot;&gt;Network 정리 &lt;/span&gt;--&gt;
&lt;!--&lt;ul class=&quot;table-of-contents-list&quot;&gt;--&gt;
&lt;!--    &lt;li&gt;&lt;a href=&quot;./structure&quot;&gt;스택과 큐의 특징&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li&gt;&lt;a href=&quot;./heap&quot;&gt;힙의 특징&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--&lt;/ul&gt;--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;소켓&quot;&gt;소켓&lt;/h2&gt;
&lt;p&gt;소켓이란 프로그램이 네트워크 상에서 데이터를 송신과 수신을 하기위한 연결부이다. 일반적으로 tcp/ip프로토콜을 사용하거나 웹 소켓을 이용한다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;프로토콜&lt;/strong&gt;        &lt;br /&gt;
어떤 시스템이 다른 시스템과 통신을 원활하게 수용하도록 해주는 통신 규약이다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;소켓-통신의-흐름&quot;&gt;소켓 통신의 흐름&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64240637/133592555-52a41f5c-9e58-43a3-9b2c-92ffa326852c.png&quot; alt=&quot;쏘켓&quot; /&gt;&lt;/p&gt;

&lt;p&gt;소켓의 흐름은 서버소켓과 클라이언트소켓으로 이야기 할 수 있다&lt;/p&gt;

&lt;h4 id=&quot;클라이언트&quot;&gt;클라이언트&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;socket()함수로 소켓을 연다&lt;/li&gt;
  &lt;li&gt;connect() 함수를 이용해 통신 할 서버의 ip, port번호에 통신을 시도한다&lt;/li&gt;
  &lt;li&gt;통신을 시도 할때 서버가 accept()함수를 사용해 클라이언트의 socket descriptor를 반환한다&lt;/li&gt;
  &lt;li&gt;클라이언트와 서버가 서로 read(), writer()를 하며 통신한다(반복)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;서버&quot;&gt;서버&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;socket()함수를 이용하여 소켓을 생성한다&lt;/li&gt;
  &lt;li&gt;bind()함수로 ip와 port번호를 설정한다&lt;/li&gt;
  &lt;li&gt;listen()함수로 클라이언트의 접근 요청에 수신 대기열을 만들어서 몇 개의 클라이언트를 대기 시킬지를 결정한다&lt;/li&gt;
  &lt;li&gt;accept()함수를 사용하여 클라이언트와의 연결을 기다린다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;소켓통신은 http통신과는 다르게 서로 연결을 유지하는 양방향 통신이다. 서버와 클라이언트가 실시간으로 데이터를 주고받는 상황이 필요한 경우에 주로 사용된다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;웹-소켓&quot;&gt;웹 소켓&lt;/h2&gt;
&lt;p&gt;웹소켓은 서버와 클라이언트간의 socket connection을 유지해 언제든 양방향 통신이나 데이터 전송이 가능하게 하는 기술이다  &lt;br /&gt;
즉 http통신의 한계(단방향, 재접속)를 보완하는 기술이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;웹-소켓-이전-비슷한-기술&quot;&gt;웹 소켓 이전 비슷한 기술&lt;/h3&gt;

&lt;h3 id=&quot;polling&quot;&gt;Polling&lt;/h3&gt;
&lt;p&gt;서버로 일정 주기마다 요청을 송신한다 &lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/64240637/133594391-1c7fc979-b632-4a51-90a9-0a3abae7f1ef.png&quot; alt=&quot;polliing&quot; /&gt;&lt;/p&gt;

&lt;p&gt;real time통신에서는 언제 통신이 발생할지는 예측이 불가능하다. 그렇기에 불필요한 request와 connection이 발생한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;real time = 실시간&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;long-polling&quot;&gt;Long Polling&lt;/h3&gt;
&lt;p&gt;서버에 요청을 보내고 이벤트가 발생하여 응답을 받을 때까지 연결을 종료하지 않는다. 응답을 받으면 연결을 끊고 다시 재요청을 한다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64240637/133594388-498189c6-6de4-482a-99b9-6db4eb994474.png&quot; alt=&quot;longpolling&quot; /&gt;&lt;/p&gt;

&lt;p&gt;많은 양의 메시지가 전송 될 경우 polling과 똑같다&lt;/p&gt;

&lt;h3 id=&quot;streaming&quot;&gt;Streaming&lt;/h3&gt;
&lt;p&gt;서버에 요청을 보내고 연결을 유지하며 데어터를 수신한다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64240637/133594384-d2b2bf4b-981c-451d-b125-d83ec768a919.png&quot; alt=&quot;스트리밍&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트에서 서버로의 데이터 송신이 어렵다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;즉 위의 방법들은 모두 HTTP를 통해 통신하기 때문에 request, response 둘 다 header가 불필요하게 크다&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;웹-소켓의-핸드-쉐이크&quot;&gt;웹 소켓의 핸드 쉐이크&lt;/h3&gt;

&lt;p&gt;웹 소켓도 tcp의 핸드 쉐이크처럼 연결을 하는 과정이 존재한다. 이때 웹 소켓의 핸드 쉐이킹은 http(80)나 https(443)의 프로토콜을 통해서 이루어진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64240637/133595432-4a2d221b-8264-4741-945a-bc4056f4dfc3.png&quot; alt=&quot;웹소켓&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클라이언트에서 아래와 같은 표준적인 http 요청 header를 보낸다 (이때 http버전은 반드시 1.1 이상이여야하며 get방식이여야 한다 )&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;GET /chat HTTP/1.1  &lt;br /&gt;
Host: example.com:8000 # 웹 소켓의 서버 구조 &lt;br /&gt;
Upgrade: websocket # 현재 클라이언트. 서버 전송 프로토콜 연결에서 다른 프로토콜로 업그레이드/변경하기 위한 규칙 &lt;br /&gt;
Connection: Upgrade # upgrade헤더가 명시되어 있는 경우 송신자는 반드시 connection헤더 필드도 함께 전송해야 한다 &lt;br /&gt;
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== # 양쪽 통신자의 신원을 확인하는 키라고 생각하면 된다  &lt;br /&gt;
Sec-WebSocket-Version: 13&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;서버가 클라이언트에게 웹소켓 프로토콜로 업그레드 하는 것을 승인하면 아래의 헤더를 전송한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;101 Switching Protocols &lt;br /&gt;
Upgrade: websocket  &lt;br /&gt;
Connection: Upgrade   &lt;br /&gt;
Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;핸드 쉐이킹이 완료되면 http프로토콜은 &lt;strong&gt;ws&lt;/strong&gt; 프로토콜로 변경된다 (wss -&amp;gt; https처럼 데이터 보안을 위해서 ssl을 적용한 프로토콜)
 이후 서로 messge를 주고받는다 (message : 여러 프레임이 모여 구성하는 하나의 논리적 메시지 단위)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;프레임(frame)&lt;/strong&gt;    &lt;br /&gt;
커뮤니케이션에서 가장 작은 단위의 데이터이다 (작은헤더 + payload로 구성)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;페이로드(payload)&lt;/strong&gt;     &lt;br /&gt;
데이터와 함께 전송되는 데이터중, 헤더와 메타데이터와 같은 데이터는 제외한 전송의 근본적인 목적이 되는 데이터의 일부분이다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;웹-소켓-프로토콜-특징&quot;&gt;웹 소켓 프로토콜 특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;최초 접속할때 http 프로토콜 위에서 핸드쉐이킹을 하기 때문에 http header를 사용한다&lt;/li&gt;
  &lt;li&gt;웹 소켓을 위한 별도의 포트는 없으며 기존포트(80, 443)를 사용한다&lt;/li&gt;
  &lt;li&gt;프레임으로 구성된 메시지라는 논리적 단위로 송수신된다&lt;/li&gt;
  &lt;li&gt;메시지에 포함될 수 있는 교환 가능한 메시지는 텍스트와 바이너리이다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;socketio&quot;&gt;socket.io&lt;/h2&gt;
&lt;p&gt;socket.io란 WebSocket과 같이 클라이언트와 서버의 양방향 통신을 가능하게 해주는 모듈이다. WebSocket은 HTML5이후에 나왔기 때문에 엊ㄴ의 기술로 구현된 서비스에서 WebSocket처럼 사용할 수 있도록 도와주는 기술이다.&lt;/p&gt;

&lt;p&gt;socket.io는 통신을 시작할때 각 브라우저에 대해서 webSocket, streaming등등에서 가장 적절한 방법을 찾아 메시지를 보내준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h5 id=&quot;reference&quot;&gt;reference&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://duckdevelope.tistory.com/19&quot;&gt;https://duckdevelope.tistory.com/19&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://rubberduck-debug.tistory.com/123&quot;&gt;https://rubberduck-debug.tistory.com/123&lt;/a&gt;   &lt;br /&gt;
&lt;a href=&quot;https://velog.io/@y1andyu&quot;&gt;https://velog.io/@y1andyu&lt;/a&gt;  &lt;br /&gt;
&lt;a href=&quot;https://www.youtube.com/watch?v=MPQHvwPxDUw&quot;&gt;https://www.youtube.com/watch?v=MPQHvwPxDUw&lt;/a&gt;&lt;/p&gt;</content><author><name>jung</name></author><category term="network" /><summary type="html"></summary></entry><entry><title type="html">0913 TIL</title><link href="https://heejung-gjt.github.io/til45" rel="alternate" type="text/html" title="0913 TIL" /><published>2021-09-13T17:50:00+09:00</published><updated>2021-09-13T17:50:00+09:00</updated><id>https://heejung-gjt.github.io/til45</id><content type="html" xml:base="https://heejung-gjt.github.io/til45">&lt;h2 id=&quot;210913-계획&quot;&gt;210913 계획&lt;/h2&gt;

&lt;h4 id=&quot;am-1150-&quot;&gt;AM 11:50 ~&lt;/h4&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;해야-할-일&quot;&gt;해야 할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;알고리즘 백준 1699, 2133, 9461, 2225, 2751 문제 풀기&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;jwt 실습하기&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;알고리즘 문제 풀고 jwt 실습하니 하루가 다 갔다… ^^ &lt;br /&gt;
jwt를 공부하면서 역할 중 하나가 백엔드와 프론트를 정확히 나눌수 있는 역할을 한다는데 나한테는 생각보다 어려운 개념
이다… 좀 더 공부를 해야 할 듯 싶다 !&lt;/p&gt;</content><author><name>jung</name></author><category term="til" /><summary type="html"></summary></entry><entry><title type="html">0911 TIL</title><link href="https://heejung-gjt.github.io/til44" rel="alternate" type="text/html" title="0911 TIL" /><published>2021-09-11T17:50:00+09:00</published><updated>2021-09-11T17:50:00+09:00</updated><id>https://heejung-gjt.github.io/til44</id><content type="html" xml:base="https://heejung-gjt.github.io/til44">&lt;h2 id=&quot;210911-계획&quot;&gt;210911 계획&lt;/h2&gt;

&lt;h4 id=&quot;pm-200-&quot;&gt;PM 2:00 ~&lt;/h4&gt;

&lt;p&gt;풀었던 알고리즘 문제를 블로그에 정리하고 오늘은 꼭 3문제 이상은 풀 예정이다 !! 그리고 JWT 이론은 정리해보자 !!&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;해야-할-일&quot;&gt;해야 할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;DP 알고리즘 다시 풀어보기(2문제)&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;DP 알고리즘 블로그 정리하기(9/10)&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;DP 알고리즘 풀기(3문제)&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;JWT 공부하기&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;DP는 너무너무 어려워~~~ 규칙 찾는게 아직도 쉽지가 않다… ^^&lt;/p&gt;</content><author><name>jung</name></author><category term="til" /><summary type="html"></summary></entry><entry><title type="html">JWT란 (작성중..)</title><link href="https://heejung-gjt.github.io/jwt" rel="alternate" type="text/html" title="JWT란 (작성중..)" /><published>2021-09-11T17:45:00+09:00</published><updated>2021-09-11T17:45:00+09:00</updated><id>https://heejung-gjt.github.io/jwt</id><content type="html" xml:base="https://heejung-gjt.github.io/jwt">&lt;!--&lt;span class=&quot;table-of-contents-list&quot;&gt;Network 정리 &lt;/span&gt;--&gt;
&lt;!--&lt;ul class=&quot;table-of-contents-list&quot;&gt;--&gt;
&lt;!--    &lt;li&gt;&lt;a href=&quot;./structure&quot;&gt;스택과 큐의 특징&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li&gt;&lt;a href=&quot;./heap&quot;&gt;힙의 특징&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--&lt;/ul&gt;--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;jwt&quot;&gt;JWT&lt;/h2&gt;</content><author><name>jung</name></author><category term="jwt" /><summary type="html"></summary></entry><entry><title type="html">(프로그래머스 with python) 11722 가장 긴 감소하는 부분 수열</title><link href="https://heejung-gjt.github.io/algorithm10" rel="alternate" type="text/html" title="(프로그래머스 with python) 11722 가장 긴 감소하는 부분 수열" /><published>2021-09-10T18:00:00+09:00</published><updated>2021-09-10T18:00:00+09:00</updated><id>https://heejung-gjt.github.io/algorithm10</id><content type="html" xml:base="https://heejung-gjt.github.io/algorithm10">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;11722-가장-긴-감소하는-부분-수열&quot;&gt;11722 가장 긴 감소하는 부분 수열&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64240637/132938885-86509141-0347-4928-9c52-d840931494a9.png&quot; alt=&quot;11722 가장 갑소하는 부분수열&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;로직-구현-순서&quot;&gt;로직 구현 순서&lt;/h3&gt;

&lt;p&gt;11055번과 거의 똑같다. 11055번은 값이 증가하는지에 대한 조건을 걸었다면 이 문제는 값이 감소하는지 비교한 후 그 중 max의 값을 찾아 업데이트 해주면 된다. arr[i]이 이전값인 arr[j]보다 작으면 아래의 로직이 실행된다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>jung</name></author><category term="algorithm" /><summary type="html"></summary></entry></feed>