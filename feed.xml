<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://heejung-gjt.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://heejung-gjt.github.io/" rel="alternate" type="text/html" /><updated>2021-09-23T11:08:44+09:00</updated><id>https://heejung-gjt.github.io/</id><title type="html">Studying  Develop</title><subtitle>개발 공부하는 블로그</subtitle><entry><title type="html">0923 TIL</title><link href="https://heejung-gjt.github.io/til52" rel="alternate" type="text/html" title="0923 TIL" /><published>2021-09-22T20:59:00+09:00</published><updated>2021-09-22T20:59:00+09:00</updated><id>https://heejung-gjt.github.io/til52</id><content type="html" xml:base="https://heejung-gjt.github.io/til52">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;210923-계획&quot;&gt;210923 계획&lt;/h2&gt;

&lt;h4 id=&quot;am-830-&quot;&gt;AM 8:30 ~&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;D-37&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;해야-할-일&quot;&gt;해야 할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;sql 강의 듣고 정리하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 sql select 7문제 풀이&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>jung</name></author><category term="til" /><summary type="html"></summary></entry><entry><title type="html">(MYSQL) DML CRUD - 데이터 생성, 읽기, 갱신, 삭제하기</title><link href="https://heejung-gjt.github.io/db3" rel="alternate" type="text/html" title="(MYSQL) DML CRUD - 데이터 생성, 읽기, 갱신, 삭제하기" /><published>2021-09-22T20:52:00+09:00</published><updated>2021-09-22T20:52:00+09:00</updated><id>https://heejung-gjt.github.io/db3</id><content type="html" xml:base="https://heejung-gjt.github.io/db3">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-데이터-생성&quot;&gt;1. 데이터 생성&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;넣을 데이터는 테이블 필드의 순서에 맞게 넣어주면 된다. 이때 id같이 auto_increment로 지정되어 있는 필드는
자동으로 값이 카운트 되기 때문에 &lt;strong&gt;직접 넣을 데이터를 정할 수 있다&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xhtml&quot;&gt;INSERT INTO {테이블명} VALUES(넣을 데이터1, 넣을 데이터2,..);

EX)
INSERT INTO product VALUES(1, '여자바지', 10000, 8000);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;넣을 데이터 직접 지정해서 넣기&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xhtml&quot;&gt;INSERT INTO {테이블명}(지정한 데이터 필드1, 필드2...) VALUES('넣을 데이터1', 2,,,,);

EX)
INSERT INTO product(product_name, ori_price, sale_price) VALUES('어린이 바지', 20000, 7000);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-데이터-전체-읽기&quot;&gt;2. 데이터 전체 읽기&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xhtml&quot;&gt;SELECT * FROM {테이블명};

SELECT * FROM product;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3-정한-필드로-데이터-읽기&quot;&gt;3. 정한 필드로 데이터 읽기&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xhtml&quot;&gt;SELECT {필드명} FROM {테이블명};

SELECT name FROM computer_core;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;4-where절로-조건에-맞는-데이터-읽기&quot;&gt;4. WHERE절로 조건에 맞는 데이터 읽기&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xhtml&quot;&gt;SELECT name FROM computer_core WHERE id  &amp;lt; 2; # computer_core에서 id가 2보다 작은 name 출력
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;5-order-by절로-데이터-정렬하기&quot;&gt;5. ORDER BY절로 데이터 정렬하기&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;DESC가 내림차순이고 ASC가 오름차순으로 정렬이다. 이때 뒤에 아무것도 쓰지 않으면 디폴트값인 ASC, 즉 오름차순 정렬이 된다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xhtml&quot;&gt;SELECT name FROM cumputer_core ORDER BY id DESC; # id역순으로 정렬
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;6-like절로-데이터-필터하기&quot;&gt;6. LIKE절로 데이터 필터하기&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xhtml&quot;&gt;# comupter_core테이블에 model_type에 Lake가 들어가 있는 데이터의  model_type과 name 출력  

SELECT model_type, name FROM cumputer_core WHERE model_type LIKE '%Lake%';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;7-limit으로-데이터-개수-제한하기&quot;&gt;7. LIMIT으로 데이터 개수 제한하기&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xhtml&quot;&gt;# computer_core테이블에 id와 name을 출력하는데 첫번째 이후 데이터부터 2번째까지의 데이터를 출력 
즉 id를 기준으로 id =2, 3번이 출력된다    

SELECT id, name FROM computer_core LIMIT 1, 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;8-update로-데이터-수정하기&quot;&gt;8. UPDATE로 데이터 수정하기&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;첫번째 예시를 보면 모든 name이 변경되는 로직이다. 이는 db내에서 잘못 입력한 것으로 간주하여 에러를 발생시킨다. 
변경할때는 WHERE절을 함께 써서 조건을 정해준다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xhtml&quot;&gt;UPDATE computer_core SET name = 'i5';  # computer_core 안에 name을 모두 i5로 변경 (에러발생)  

UPDATE computer_core SET name = 'i100' WHERE id = '3'; # compuer_core안에 id가 3인 데이터의 name을 i100으로 변경   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;</content><author><name>jung</name></author><category term="database" /><summary type="html"></summary></entry><entry><title type="html">0922 TIL</title><link href="https://heejung-gjt.github.io/til51" rel="alternate" type="text/html" title="0922 TIL" /><published>2021-09-22T20:40:00+09:00</published><updated>2021-09-22T20:40:00+09:00</updated><id>https://heejung-gjt.github.io/til51</id><content type="html" xml:base="https://heejung-gjt.github.io/til51">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;210922-계획&quot;&gt;210922 계획&lt;/h2&gt;

&lt;h4 id=&quot;am-1100-&quot;&gt;AM 11:00 ~&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;D-38&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;해야-할-일&quot;&gt;해야 할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;알고리즘 dfs/bfs 2문제&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;장고 user view 리펙토링(진행중..)&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;준비하고 있는 프로그램이 약 한달 남았다.. 점점 수준이 높아져서 코테난이도도 많이 올라간듯 싶다.. 그래도
해보고 싶은 프로그램이니 남은시간 열심히 준비해보려고 한다 !!&lt;/p&gt;</content><author><name>jung</name></author><category term="til" /><summary type="html"></summary></entry><entry><title type="html">0920 TIL</title><link href="https://heejung-gjt.github.io/til50" rel="alternate" type="text/html" title="0920 TIL" /><published>2021-09-20T20:59:00+09:00</published><updated>2021-09-20T20:59:00+09:00</updated><id>https://heejung-gjt.github.io/til50</id><content type="html" xml:base="https://heejung-gjt.github.io/til50">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;210920-계획&quot;&gt;210920 계획&lt;/h2&gt;

&lt;h4 id=&quot;am-900-&quot;&gt;AM 9:00 ~&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;D-40&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;해야-할-일&quot;&gt;해야 할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;알고리즘 dfs/bfs (2178, 2146, 1991)&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;SQL 강의 듣기(인프런)&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>jung</name></author><category term="til" /><summary type="html"></summary></entry><entry><title type="html">0917 TIL</title><link href="https://heejung-gjt.github.io/til49" rel="alternate" type="text/html" title="0917 TIL" /><published>2021-09-16T20:59:00+09:00</published><updated>2021-09-16T20:59:00+09:00</updated><id>https://heejung-gjt.github.io/til49</id><content type="html" xml:base="https://heejung-gjt.github.io/til49">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;210917-계획&quot;&gt;210917 계획&lt;/h2&gt;

&lt;h4 id=&quot;am-900-&quot;&gt;AM 9:00 ~&lt;/h4&gt;

&lt;p&gt;운동대신 공부를 일찍 시작했다 ! (자기합리화…)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;해야-할-일&quot;&gt;해야 할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;네트워크 소켓, 웹서버, was 정리&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>jung</name></author><category term="til" /><summary type="html"></summary></entry><entry><title type="html">0916 TIL</title><link href="https://heejung-gjt.github.io/til48" rel="alternate" type="text/html" title="0916 TIL" /><published>2021-09-16T20:50:00+09:00</published><updated>2021-09-16T20:50:00+09:00</updated><id>https://heejung-gjt.github.io/til48</id><content type="html" xml:base="https://heejung-gjt.github.io/til48">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;210916-계획&quot;&gt;210916 계획&lt;/h2&gt;

&lt;h4 id=&quot;am-1120-&quot;&gt;AM 11:20 ~&lt;/h4&gt;

&lt;p&gt;내일부터는 무조건 운동을 할 예정이다 ! 내 등살이 장난아니다…..&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;해야-할-일&quot;&gt;해야 할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;dfs/bfs 알고리즘 9466, 2667, 4963, 7976&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;기본 알고리즘 11650, 1165, 10814&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;dp 11726&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;네트워크 소켓 정리&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;python 메모리 관리 과정&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;python is vs ==&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;오늘 공부했던 소켓이나 파이썬 메모리 둘다 꽤 흥미로웠고 재밌었다 ^^ 둘다 강의를 참고하여 들었는데 발표하는 분들 정말
대단해보였다.. 내일 다시 복습해야지 ~!&lt;/p&gt;</content><author><name>jung</name></author><category term="til" /><summary type="html"></summary></entry><entry><title type="html">(Python) is와 == 의 차이점</title><link href="https://heejung-gjt.github.io/python13" rel="alternate" type="text/html" title="(Python) is와 == 의 차이점" /><published>2021-09-16T18:20:00+09:00</published><updated>2021-09-16T18:20:00+09:00</updated><id>https://heejung-gjt.github.io/python13</id><content type="html" xml:base="https://heejung-gjt.github.io/python13">&lt;!--&lt;span class=&quot;table-of-contents-list&quot;&gt;Python 목록 순서 &lt;/span&gt;--&gt;
&lt;!--&lt;ul class=&quot;table-of-contents-list&quot;&gt;--&gt;
&lt;!--    &lt;li&gt;&lt;a href=&quot;./python-DataStructure&quot;&gt;Python 강좌(1) - 자료구조&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li class=&quot;content01 content&quot;&gt;1. 리스트&lt;/li&gt;--&gt;
&lt;!--    &lt;li class=&quot;content02 content&quot;&gt;2. 튜플&lt;/li&gt;--&gt;
&lt;!--    &lt;li class=&quot;content03 content&quot;&gt;3. 딕셔너리&lt;/li&gt;--&gt;
&lt;!--    &lt;li class=&quot;content04 content&quot;&gt;4. 문자열 리스트로 변환 후 딕셔너리 변환&lt;/li&gt;--&gt;
&lt;!--    &lt;li &gt;&lt;a href=&quot;./python-Function&quot;&gt;Python 강좌(2) - 함수&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li &gt;&lt;a href=&quot;./python-INOutput&quot;&gt;Python 강좌(3) - 입출력&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li &gt;&lt;a href=&quot;./python-Class&quot;&gt;Python 강좌(4) - 클래스&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li &gt;&lt;a href=&quot;./python-Exception&quot;&gt;Python 강좌(5) - 예외처리&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--&lt;/ul&gt;--&gt;

&lt;!--&lt;script&gt;--&gt;
&lt;!--    const content = document.querySelector('.content')--&gt;
&lt;!--    const lists01 = document.querySelector('.content01');--&gt;
&lt;!--    const lists02 = document.querySelector('.content02');--&gt;
&lt;!--    const lists03 = document.querySelector('.content03');--&gt;
&lt;!--    const lists04 = document.querySelector('.content04');--&gt;
&lt;!--    lists01.addEventListener('click',(event)=&gt;{--&gt;
&lt;!--        window.scrollTo(0,850);--&gt;
&lt;!--    });--&gt;
&lt;!--    lists02.addEventListener('click',(event)=&gt;{--&gt;
&lt;!--        window.scrollTo(0,3500);--&gt;
&lt;!--    });--&gt;
&lt;!--    lists03.addEventListener('click',(event)=&gt;{--&gt;
&lt;!--        window.scrollTo(0,4700);--&gt;
&lt;!--    });--&gt;
&lt;!--    lists04.addEventListener('click',(event)=&gt;{--&gt;
&lt;!--        window.scrollTo(0,8300);--&gt;
&lt;!--    });--&gt;

&lt;!--&lt;/script&gt;--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;a-is-b&quot;&gt;a is b&lt;/h2&gt;

&lt;p&gt;is는 메모리 주소를 비교하는 연산자이다.  아래의 코드를 보면 a와 b 둘다 동일한 값이 할당되었지만 실제 비교가 되는 값은
100이 아니라 100을 담고 있는 주소의 값이 비교된다. 이때 a와 b는 다른 메모리주소를 가지고 있기 때문에 두개의 주소값은
동일하지 않다&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# False&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;a--b&quot;&gt;a == b&lt;/h2&gt;

&lt;p&gt;==는 두개의 값만을 비교하는 연산자이다. 아래의 코드를 보면 할당된 값은 동일하기 때문에 True가 나온다&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# True&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;is는 == 에 비해 약간 빠르다&lt;/strong&gt;  &lt;br /&gt;
== 는 메모리 주소를 불러온 뒤 그 메모리에 저장되어 있는 값을 비교하고 is는 메모리 주소만을 비교하기 때문이다. 즉 
==는 한 depth더 비교하기 때문에 연산이 살짝 느린것을 알 수 있다&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;변수&lt;/strong&gt;  &lt;br /&gt;
특정 메모리 주소를 담아서 메모리 주소에 붙이는 라벨과 같다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;파이썬에서는 변수는 값이 아닌 메모리 주소를 담고 있다&lt;/p&gt;</content><author><name>jung</name></author><category term="python" /><summary type="html"></summary></entry><entry><title type="html">(Python) 파이썬 메모리 관리</title><link href="https://heejung-gjt.github.io/python12" rel="alternate" type="text/html" title="(Python) 파이썬 메모리 관리" /><published>2021-09-16T17:20:00+09:00</published><updated>2021-09-16T17:20:00+09:00</updated><id>https://heejung-gjt.github.io/python12</id><content type="html" xml:base="https://heejung-gjt.github.io/python12">&lt;!--&lt;span class=&quot;table-of-contents-list&quot;&gt;Python 목록 순서 &lt;/span&gt;--&gt;
&lt;!--&lt;ul class=&quot;table-of-contents-list&quot;&gt;--&gt;
&lt;!--    &lt;li&gt;&lt;a href=&quot;./python-DataStructure&quot;&gt;Python 강좌(1) - 자료구조&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li class=&quot;content01 content&quot;&gt;1. 리스트&lt;/li&gt;--&gt;
&lt;!--    &lt;li class=&quot;content02 content&quot;&gt;2. 튜플&lt;/li&gt;--&gt;
&lt;!--    &lt;li class=&quot;content03 content&quot;&gt;3. 딕셔너리&lt;/li&gt;--&gt;
&lt;!--    &lt;li class=&quot;content04 content&quot;&gt;4. 문자열 리스트로 변환 후 딕셔너리 변환&lt;/li&gt;--&gt;
&lt;!--    &lt;li &gt;&lt;a href=&quot;./python-Function&quot;&gt;Python 강좌(2) - 함수&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li &gt;&lt;a href=&quot;./python-INOutput&quot;&gt;Python 강좌(3) - 입출력&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li &gt;&lt;a href=&quot;./python-Class&quot;&gt;Python 강좌(4) - 클래스&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--    &lt;li &gt;&lt;a href=&quot;./python-Exception&quot;&gt;Python 강좌(5) - 예외처리&lt;/a&gt;&lt;/li&gt;--&gt;
&lt;!--&lt;/ul&gt;--&gt;

&lt;!--&lt;script&gt;--&gt;
&lt;!--    const content = document.querySelector('.content')--&gt;
&lt;!--    const lists01 = document.querySelector('.content01');--&gt;
&lt;!--    const lists02 = document.querySelector('.content02');--&gt;
&lt;!--    const lists03 = document.querySelector('.content03');--&gt;
&lt;!--    const lists04 = document.querySelector('.content04');--&gt;
&lt;!--    lists01.addEventListener('click',(event)=&gt;{--&gt;
&lt;!--        window.scrollTo(0,850);--&gt;
&lt;!--    });--&gt;
&lt;!--    lists02.addEventListener('click',(event)=&gt;{--&gt;
&lt;!--        window.scrollTo(0,3500);--&gt;
&lt;!--    });--&gt;
&lt;!--    lists03.addEventListener('click',(event)=&gt;{--&gt;
&lt;!--        window.scrollTo(0,4700);--&gt;
&lt;!--    });--&gt;
&lt;!--    lists04.addEventListener('click',(event)=&gt;{--&gt;
&lt;!--        window.scrollTo(0,8300);--&gt;
&lt;!--    });--&gt;

&lt;!--&lt;/script&gt;--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;파이썬-메모리-관리&quot;&gt;파이썬 메모리 관리&lt;/h2&gt;

&lt;p&gt;파이썬은 메모리를 직접 관리하지 않기 때문에 메모리에 대한 신경을 다른 언어에 비해 덜 쓸 수 있다. 파이썬에서는 &lt;strong&gt;레퍼런스 카운트(Reference Counts)와 가비지 콜렉션(Garbage Collection)에 의해 관리된다&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;레퍼런스-카운트&quot;&gt;레퍼런스 카운트&lt;/h2&gt;
&lt;p&gt;파이썬은 내부적으로 malloc()과 free() 함수를 많이 사용하기 때문에 메모리 누수(동적 할당 되는 메모리의 크기는 런타임 내내 변하기 때문에 사용이 끝난 메모리를 해제하지 않으면 메모리가 부족해지는 현상)의 위험이 있다. 그렇기 때문에 메모리를 관리하기 위해서 사용된다  &lt;br /&gt;
레퍼런스 카운트는 &lt;strong&gt;파이썬의 모든 객체에 카운트를 포함하고 객체가 참조될때 카운트가 증가, 참조가 삭제될때 카운트를 감소시키는 방식으로 작동된다.&lt;/strong&gt;  객체의 reference count가 0이 되면 객체의 메모리 할당이 해제된다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;malloc()&lt;/strong&gt;    &lt;br /&gt;
동적으로 &lt;strong&gt;메모리를 할당하는 함수&lt;/strong&gt; 로 힙 영역에 메모리를 할당하는 함수&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;free()&lt;/strong&gt;      &lt;br /&gt;
힙 영역에 할당받은 메모리 공간을 다시 os로 반환해주는 함수이다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;특정 메모리 주소를 참조하는 곳의 수가 0이 될 경우 다음 GC때 메모리에서 해제가 된다&lt;/p&gt;

&lt;p&gt;레퍼런스 카운트는 getrefcount()를 통해 파라미터로 전달된 객체의 카운트를 확인할 수 있다  &lt;br /&gt;
(여기서 처음 출력되는 카운트 값이 1이 아닌 이유는 a의 객체가 getrefcount함수의 인자로 넘어가기 때문에 인자로 넘겨주는 순간 +1 이 된다)&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'hello'&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'count {sys.getrefcount(a)}'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'count {sys.getrefcount(a)}'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'count {sys.getrefcount(a)}'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'count {sys.getrefcount(a)}'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
count 2
count 3
count 4
count 3
&quot;&quot;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;순환참조시-레퍼런스-카운트-문제&quot;&gt;순환참조시 레퍼런스 카운트 문제&lt;/h3&gt;

&lt;p&gt;이때 레퍼런스 카운트에는 문제가 존재한다. 순환참조시 a의 참조횟수는 1이지만 이 객체에는 더이상 접근할 수 없고 레퍼런스 카운트 방식으로는 메모리에서 해제될 수 없다&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;del&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;순환참조&lt;/strong&gt;  &lt;br /&gt;
객체가 자기 자신을 가리키는 것을 말한다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이때 가비지 컬렉션을 사용하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;generational-garbage-collector&quot;&gt;Generational Garbage Collector&lt;/h2&gt;
&lt;p&gt;gc는 내부적으로 &lt;strong&gt;세대&lt;/strong&gt; 와 &lt;strong&gt;임계값&lt;/strong&gt; 을 통해서 가비지 컬렉션 주기와 객체를 관리한다. 
총 3세대가 있으며 최근에 생성된 객체는 0세대로 들어가고 오랜된 객체는 이전 세대로 이동한다.&lt;/p&gt;

&lt;p&gt;(최근 생성된 객체는 0세대에 들어가고 오래된 객체일수록 2세대로 이동된다. 그 이유는 최근에 만들어진 객체가 오래된 객체보다 해제될 가능성이 훨씬 높다는 가설이 있기 때문이다)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;generation(세대)&lt;/strong&gt; : 가비지 컬렉터는 메모리의 모든 객체를 추적하는데 새로운 객체는 1세대 가비지 수집기에서 수명을 시작한다. 가비지 컬렉션이 실행되고 객체가 남아있으면 해당 객체는 두번째 이전 세대로 올라간다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;threshold(임계값)&lt;/strong&gt; : 각 세대마다 즉 각 제너레이션마다 가비지 커렉터 모듈에는 임계값 개수의 개체가 있다. 객체 수가 임계값을 초과하면 가비지 컬렉션이 실행되고 이 과정에서 살아남은 객체는 이전 세대로 옮겨진다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;가비지 컬렉션을 사용하기 위해서 GC module을 사용한다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;메모리-할당-내부-동작&quot;&gt;메모리 할당 내부 동작&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;PyObject_GC_MALLOC()&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;collect_generations()&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;gc의 set_threshold()는 가비지 컬렉터의 구성된 임계값을 확인할 수 있다. 만약 아래처럼 임계값이 3인 경우라고 가정하자(각 제너레이션, 즉 각 세대에 들어갈 수 있는 객체의 최대값)&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;gc&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;gc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_threshold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;값이 할당되면 파이썬 내부적으로 PyObject_GC_Malloc() 함수가 호출되어 hi라는 값은 메모리에 할당되게 된다. 이후 해당 함수는 할당된 메모리 주소를 리턴하게 되고 메모리 주소는 a로 들어가게 된다. 제너레이터(0세대)에는 hi라는 값이 들어가게 된다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'hi'&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;PyObject_GC_Malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;b라는 변수에 how라는 값을 넣었고 마찬가지로 PyObject_GC_Malloc() 함수가 호출되어 how라는 값은 메모리에 할당되게 된다. 이후 how값은 제너레이터(0세대)에 들어가게 된다&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'how'&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;PyObject_GC_Malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;c라는 변수에 are라는 값을 넣었고 PyObject_GC_Malloc() 함수가 호출되어 are라는 값은 메모리에 할당되게 된다. 이후 are값은 제너레이터(0세대)에 들어가게 된다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'you'&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;PyObject_GC_Malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이후 you라는 값이 함수 호출에 의해 메모리에 할당되는데 제너레이터의 임계값은 3이기 때문에 you가 들어가면 threshold를 초과하게 된다. 
더이상 0세대에는 변수를 할당할 수 없게 된다. &lt;br /&gt;
이때는 &lt;strong&gt;PyObject_GC_Malloc()함수에서 collect_generations(–)라는 함수를 호출한다&lt;/strong&gt; collect_generstions은 이전 세대부터 각 객체가 몇개 들어가 있는지 체크한다. 체크한뒤 초과가 된 제너레이션을 찾아 초과가 된 세대에 가비지 컬렉터를 돌리라는 명령을 한다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;collect함수는 0세대에 있는 모든 값들을 불러온 뒤 값의 레퍼런스 카운트를 체크한다. 레퍼런스 카운트가 0일 경우 값을 메모리에서 지우게 된다. 0이 아닌 경우 해당 값은 위의 제너레이션 즉 1세대로 올리게 된다.  즉 1세대에는 hi, how, are라는 값들이 저장되고 0세대에는 you라는 값이 저장된다.&lt;/p&gt;

&lt;p&gt;가비지 컬렉터는 제너레이션에 값들이 임계값을 초과할 경우 동작해서 레퍼런스 카운트 값이 0일때 해당 값을 지워주고 나머지 값들은 이전 세대로 올리는 역할을 한다&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h5 id=&quot;reference&quot;&gt;reference&lt;/h5&gt;

&lt;p&gt;두개의 글과 동영상 정리가 잘 되어 있으니 참고해보길 !&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=UwGHc6A0Jq8&amp;amp;t=1613s&quot;&gt;https://www.youtube.com/watch?v=UwGHc6A0Jq8&amp;amp;t=1613s&lt;/a&gt;  &lt;br /&gt;
&lt;a href=&quot;https://dc7303.github.io/python/2019/08/06/python-memory/&quot;&gt;https://dc7303.github.io/python/2019/08/06/python-memory/&lt;/a&gt;&lt;/p&gt;</content><author><name>jung</name></author><category term="python" /><summary type="html"></summary></entry><entry><title type="html">0915 TIL</title><link href="https://heejung-gjt.github.io/til47" rel="alternate" type="text/html" title="0915 TIL" /><published>2021-09-15T17:50:00+09:00</published><updated>2021-09-15T17:50:00+09:00</updated><id>https://heejung-gjt.github.io/til47</id><content type="html" xml:base="https://heejung-gjt.github.io/til47">&lt;h2 id=&quot;210915-계획&quot;&gt;210915 계획&lt;/h2&gt;

&lt;h4 id=&quot;am-1150-&quot;&gt;AM 11:50 ~&lt;/h4&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;해야-할-일&quot;&gt;해야 할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;bfs/dfs 알고리즘 문제 11724, 11052, 1463(dp) 문제 풀이&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;감자마켓 프로젝트 페이징 구현하기&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;필터기능 ajax, post -&amp;gt; get방식으로 변경(추후 정리예정)&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;검색기능 새로운 페이지 생성&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;실제로 get을 이론적으로 이해한것과 사용하는 것에는 아주 큰 차이가 있었다. get의 특징에 대해서는 알고 있었지만
내가 실제로 구현할때는 제대로 사용하지 않았던것이다… 아주 기본적인 것을 놓치고 있었다는 생각이 들었다. 그리고 get으로 요청받으니까
구현하기 까다로웠던 문제가 쉽게 풀려서 신기했다 ! ㅋㅋㅋ (난 왜 지금까지 몰랐던 것인가….)&lt;/p&gt;</content><author><name>jung</name></author><category term="til" /><summary type="html"></summary></entry><entry><title type="html">0914 TIL</title><link href="https://heejung-gjt.github.io/til46" rel="alternate" type="text/html" title="0914 TIL" /><published>2021-09-14T17:50:00+09:00</published><updated>2021-09-14T17:50:00+09:00</updated><id>https://heejung-gjt.github.io/til46</id><content type="html" xml:base="https://heejung-gjt.github.io/til46">&lt;h2 id=&quot;210914-계획&quot;&gt;210914 계획&lt;/h2&gt;

&lt;h4 id=&quot;am-1150-&quot;&gt;AM 11:50 ~&lt;/h4&gt;

&lt;p&gt;요즘 늦게 공부를 시작한다.. 운동을 해야 하는데 생각만큼 쉽지가 않아서 고민이다(운동 계획했던 시간에 누워있는 1인…)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;해야-할-일&quot;&gt;해야 할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;9013 알고리즘 다시 풀어보기(2011, 11052)&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;bfs/dfs 이론정리하기&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;bfs/dfs 1260, 11724 문제 풀이&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;jwt crud 구현하기(구현중….)&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;감자마켓 프로젝트 검색기능 추가하기&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;진행했던 프로젝트의 버전업을 위해 새로운 기능을 추가하고 리팩토링 하는 과정은 정말 쉽지 않다 ㅋㅋㅋ
그래도 하나씩 수정되어가는 모습을 보니 빨리 계획한 마지막 버전까지 꾸준히 업데이트 시켜보고 싶다 ~~!&lt;/p&gt;</content><author><name>jung</name></author><category term="til" /><summary type="html"></summary></entry></feed>